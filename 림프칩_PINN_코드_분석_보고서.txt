================================================================================
        림프칩 PINN 에이전트 - 코드 구조 분석 보고서
================================================================================

작성일: 2026-01-26
버전: v2 (kdecay 통합 버전)

================================================================================
목차
================================================================================
1. 프로젝트 개요
2. 폴더 구조
3. 데이터 흐름 개요
4. 데이터 전처리 모듈 상세
5. 모델 아키텍처 상세
6. 학습 과정 상세
7. 예측 과정 상세
8. 웹 애플리케이션 구조
9. 핵심 알고리즘 설명
10. 용어 사전

================================================================================
1. 프로젝트 개요
================================================================================

[목적]
이 프로젝트는 림프칩(Lymph Chip) 시뮬레이션 결과를 빠르게 예측하기 위한
대리 모델(Surrogate Model)을 구축합니다.

[배경]
- 실제 림프칩 시뮬레이션은 COMSOL 등의 소프트웨어로 수행되며 시간이 오래 걸림
- 새로운 파라미터 조합에 대해 빠른 예측이 필요한 경우가 많음
- 딥러닝 기반 대리 모델로 빠른 예측 가능

[핵심 기능]
1. 약물 분포 예측: 72시간 동안 Blood, Lymph, ECM, Decay 각 구획의 약물 비율 예측
2. 파라미터 민감도 분석: 다양한 파라미터 조합에 따른 결과 변화 시각화
3. 실시간 예측: 웹 인터페이스를 통한 즉각적인 예측 결과 제공

[사용된 기술]
- Python 3.x
- PyTorch (딥러닝 프레임워크)
- Streamlit (웹 애플리케이션)
- Plotly (인터랙티브 차트)
- NumPy, Pandas, SciPy (데이터 처리)

================================================================================
2. 폴더 구조
================================================================================

lympchip_pinn/
│
├── app.py                          # 메인 웹 애플리케이션 (Streamlit)
│
├── data/                           # 데이터 처리 모듈
│   ├── __init__.py
│   ├── preprocessor.py             # 기본 전처리기 (sol765, Summary 데이터)
│   └── timeseries_preprocessor.py  # 시계열 전처리기 (Case별 데이터)
│
├── models/                         # 모델 정의
│   ├── __init__.py
│   ├── pinn.py                     # 기본 PINN 모델 (LymphChipPINN)
│   ├── timeseries_pinn.py          # 시계열 PINN 모델
│   ├── smooth_pinn.py              # 부드러운 출력 PINN 모델
│   ├── interpolation_model.py      # 보간 기반 모델 (CaseInterpolator)
│   ├── losses.py                   # 손실 함수 정의
│   └── timeseries_losses.py        # 시계열 손실 함수
│
├── utils/                          # 유틸리티 함수
│   └── __init__.py
│
├── checkpoints/                    # 학습된 모델 저장
│   ├── final_model.pt              # 최종 비율 예측 모델
│   ├── timeseries_pinn.pt          # 시계열 PINN 모델
│   └── smooth_pinn.pt              # 부드러운 PINN 모델
│
├── train.py                        # 기본 학습 스크립트
├── train_timeseries.py             # 시계열 학습 스크립트
├── train_smooth.py                 # 부드러운 모델 학습 스크립트
├── evaluate.py                     # 평가 스크립트
└── run.py                          # 실행 스크립트

================================================================================
3. 데이터 흐름 개요
================================================================================

[전체 흐름도]

  ┌─────────────────┐
  │   Excel 파일     │
  │ (시뮬레이션 결과)  │
  └────────┬────────┘
           │
           ▼
  ┌─────────────────┐
  │   전처리기        │  ← timeseries_preprocessor.py
  │ (데이터 추출/정규화)│
  └────────┬────────┘
           │
           ├──────────────────┬──────────────────┐
           ▼                  ▼                  ▼
  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
  │  PINN 모델   │    │  보간 모델   │    │ Smooth PINN │
  │   (학습)     │    │(거리 가중치) │    │   (학습)    │
  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘
         │                  │                  │
         └──────────────────┼──────────────────┘
                            │
                            ▼
                   ┌─────────────────┐
                   │   웹 앱 (app.py) │
                   │  예측 결과 시각화  │
                   └─────────────────┘


[데이터 소스]
1. "251103 (revised)_Injection site results v2 (수정).xlsx"
   - 12개 Case의 시계열 데이터 (0~72시간)
   - 각 Case별 파라미터 조합과 Blood/Lymph/ECM/Decay 비율
   - kdecay = 0 (분해 없음)

2. "251103 (revised)_sol765.xlsx"
   - 12개 시트 (IgG, INS, ALB × 4가지 kdecay 조합)
   - 다양한 kdecay 값에 따른 Decay 데이터
   - Blood/Lymph/ECM/Decay 비율

================================================================================
4. 데이터 전처리 모듈 상세
================================================================================

[파일: data/timeseries_preprocessor.py]

┌─────────────────────────────────────────────────────────────────────────────┐
│                        TimeSeriesPreprocessor 클래스                         │
└─────────────────────────────────────────────────────────────────────────────┘

[역할]
Excel 파일에서 시뮬레이션 데이터를 추출하고 모델 학습에 적합한 형태로 변환

[주요 파라미터 (PARAM_RANGES)]
┌────────────┬─────────────────┬────────────┬────────────┬────────────┐
│ 파라미터    │ 설명            │ Low        │ Mid        │ High       │
├────────────┼─────────────────┼────────────┼────────────┼────────────┤
│ Lp_ve      │ 혈관 투과도      │ 4e-12      │ 8e-12      │ 1.6e-11    │
│ K          │ 수력 전도도      │ 1e-17      │ 1e-15      │ 1e-13      │
│ P_oncotic  │ 삼투압          │ 3145       │ 3590       │ 3815       │
│ sigma_ve   │ 반사 계수       │ 0.1        │ 0.5        │ 0.9        │
│ D_gel      │ 확산 계수       │ 1e-11      │ 3e-11      │ 1e-10      │
│ kdecay     │ 분해 속도       │ 0          │ 1.7e-6     │ 1.5e-5     │
└────────────┴─────────────────┴────────────┴────────────┴────────────┘

[정규화 방법]
실제 파라미터 값을 -1 ~ +1 범위로 변환

1. 로그 스케일 (log): Lp_ve, K, D_gel
   - 로그 변환 후 선형 정규화
   - Low → -1, Mid → 0, High → +1

2. 선형 스케일 (linear): P_oncotic, sigma_ve
   - 직접 선형 정규화
   - Low → -1, Mid → 0, High → +1

3. 로그-제로 스케일 (log_zero): kdecay
   - 0을 허용하는 특수 스케일
   - 0 → -1, Mid → 0, High → +1

[예시: Lp_ve 정규화]
- 실제 값 4e-12 (Low) → 정규화 값 -1
- 실제 값 8e-12 (Mid) → 정규화 값 0
- 실제 값 1.6e-11 (High) → 정규화 값 +1

[주요 메서드]

1. load_case_data()
   ┌──────────────────────────────────────────────────────────┐
   │ Excel 파일에서 Case별 데이터 로드                          │
   │                                                          │
   │ 입력: Excel 파일 경로                                     │
   │ 출력: {                                                   │
   │   'Case1': {                                              │
   │     'params': {Lp_ve: 8e-12, K: 1e-15, ...},             │
   │     'params_normalized': [-1, 0, 0.5, ...],  # 6개 값     │
   │     'time_series': DataFrame(time_hour, Blood, Lymph,    │
   │                              ECM, Decay)                  │
   │   },                                                      │
   │   ...                                                     │
   │ }                                                         │
   └──────────────────────────────────────────────────────────┘

2. load_decay_data()
   ┌──────────────────────────────────────────────────────────┐
   │ sol765 파일에서 Decay 데이터 로드                          │
   │                                                          │
   │ 입력: sol765.xlsx 파일 경로                               │
   │ 출력: {                                                   │
   │   'IgG kdecay 0': {                                       │
   │     'drug_type': 'IgG',                                   │
   │     'kdecay': 0,                                          │
   │     'params_normalized': [0, 0, 0, 0, 0, -1],            │
   │     'time_series': DataFrame(...)                         │
   │   },                                                      │
   │   ...                                                     │
   │ }                                                         │
   └──────────────────────────────────────────────────────────┘

================================================================================
5. 모델 아키텍처 상세
================================================================================

이 프로젝트에는 여러 종류의 모델이 있습니다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5.1 CaseInterpolator (보간 모델) - 현재 주로 사용
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[파일: models/interpolation_model.py]

[개념 - 초보자를 위한 설명]
보간(Interpolation)이란 알려진 데이터 점들 사이의 값을 추정하는 방법입니다.

예를 들어:
- Case1: Lp=Low 일 때 → Blood=10%, Lymph=60%, ECM=30%
- Case2: Lp=High 일 때 → Blood=30%, Lymph=40%, ECM=30%

만약 Lp=Mid (중간값)에서의 결과를 알고 싶다면?
→ 두 케이스의 중간값을 계산: Blood=20%, Lymph=50%, ECM=30%

[작동 원리: 역거리 가중치(IDW) 보간]

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   쿼리 파라미터 Q = [0.3, 0, 0, 0, 0, -1]                                    │
│                                                                             │
│   Step 1: 모든 케이스와의 거리 계산                                          │
│   ┌──────────────────────────────────────────────────────────┐              │
│   │ Case1 파라미터: [0, 0, 0, 0, 0, -1]                       │              │
│   │ 거리 = √((0.3-0)² + (0-0)² + ...) = 0.3                  │              │
│   │                                                          │              │
│   │ Case2 파라미터: [1, 0, 0, 0, 0, -1]                       │              │
│   │ 거리 = √((0.3-1)² + (0-0)² + ...) = 0.7                  │              │
│   │                                                          │              │
│   │ Case3 파라미터: [-1, 0, 0, 0, 0, -1]                      │              │
│   │ 거리 = √((0.3-(-1))² + ...) = 1.3                        │              │
│   └──────────────────────────────────────────────────────────┘              │
│                                                                             │
│   Step 2: 가장 가까운 k개(기본 3개) 선택                                     │
│   → Case1 (거리 0.3), Case2 (거리 0.7), Case3 (거리 1.3)                    │
│                                                                             │
│   Step 3: 역거리 가중치 계산                                                 │
│   ┌──────────────────────────────────────────────────────────┐              │
│   │ 가중치 = 1 / (거리²)                                      │              │
│   │                                                          │              │
│   │ Case1: w1 = 1/(0.3²) = 11.11                             │              │
│   │ Case2: w2 = 1/(0.7²) = 2.04                              │              │
│   │ Case3: w3 = 1/(1.3²) = 0.59                              │              │
│   │                                                          │              │
│   │ 정규화: 총합 = 13.74                                      │              │
│   │ Case1: 11.11/13.74 = 0.81 (81%)                          │              │
│   │ Case2: 2.04/13.74 = 0.15 (15%)                           │              │
│   │ Case3: 0.59/13.74 = 0.04 (4%)                            │              │
│   └──────────────────────────────────────────────────────────┘              │
│                                                                             │
│   Step 4: 가중 평균으로 최종 예측                                            │
│   ┌──────────────────────────────────────────────────────────┐              │
│   │ 예측 Blood = 0.81 × Case1_Blood + 0.15 × Case2_Blood     │              │
│   │           + 0.04 × Case3_Blood                           │              │
│   │                                                          │              │
│   │ (Lymph, ECM, Decay도 동일하게 계산)                       │              │
│   └──────────────────────────────────────────────────────────┘              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

[시간 보간]
각 케이스의 시계열 데이터는 cubic spline으로 보간됩니다.
→ 어떤 시간 t에서도 부드러운 값을 얻을 수 있음

[코드 구조]
```
class CaseInterpolator:
    def __init__(self):
        self.cases = {}  # 케이스 데이터 저장
        self.param_names = ['Lp_ve', 'K', 'P_oncotic', 'sigma_ve', 'D_gel', 'kdecay']

    def add_case(case_name, params_normalized, time_series):
        # 케이스 추가 및 시간 보간 함수 생성

    def _compute_weights(query_params, k=3):
        # 역거리 가중치 계산

    def predict(params_normalized, time_hours):
        # 가중 평균으로 예측
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5.2 LymphChipPINN (물리 기반 신경망)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[파일: models/pinn.py]

[PINN이란?]
Physics-Informed Neural Network (물리 정보 신경망)
- 일반 신경망 + 물리 법칙 제약 조건
- 데이터가 적어도 물리 법칙을 활용하여 학습 가능

[네트워크 구조]

    입력층                은닉층 (6개)              출력층
    ┌───┐               ┌───────────┐            ┌───┐
    │ t │──┐            │ Residual  │            │   │
    ├───┤  │            │  Block 1  │            │ B │ Blood
    │Lp │  │  ┌─────┐   ├───────────┤  ┌─────┐   │ L │ Lymph
    ├───┤  ├──│Input│───│ Residual  │──│Output│──│ E │ ECM
    │ K │  │  │Layer│   │  Block 2  │  │Layer │   │ D │ Decay
    ├───┤  │  └─────┘   ├───────────┤  └─────┘   └───┘
    │...│──┘    ↓       │   ...     │     ↓
    └───┘    256차원     └───────────┘   Softmax
                                       (합=100%)

[시간 인코딩 (Fourier Features)]
시간 t를 직접 사용하면 학습이 어려움
→ sin/cos 함수로 변환하여 사용

예: t = 0.5 (36시간/72시간)
→ [sin(0.5×ω₁), cos(0.5×ω₁), sin(0.5×ω₂), cos(0.5×ω₂), ...]
→ 20차원 벡터로 확장

[Residual Block (잔차 블록)]
```
입력 x ─────────┬─────────────────────────────┐
                │                             │
                ▼                             │
         ┌──────────┐                         │
         │LayerNorm │                         │
         └────┬─────┘                         │
              ▼                               │
         ┌──────────┐                         │
         │  Linear  │                         │
         └────┬─────┘                         │
              ▼                               │
         ┌──────────┐                         │
         │   SiLU   │ (활성화 함수)            │
         └────┬─────┘                         │
              ▼                               │
         ┌──────────┐                         │
         │ Dropout  │                         │
         └────┬─────┘                         │
              ▼                               │
         ┌──────────┐                         │
         │  Linear  │                         │
         └────┬─────┘                         │
              │                               │
              └───────────────┬───────────────┘
                              ▼
                            x + F(x)  ← 잔차 연결
```

잔차 연결의 장점:
- 깊은 네트워크에서 기울기 소실 문제 방지
- 학습 안정성 향상

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5.3 SmoothPINNv2 (부드러운 출력 모델)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[파일: models/smooth_pinn.py]

[목적]
시간에 따라 부드럽게 변화하는 곡선을 생성
(일반 PINN은 울퉁불퉁한 출력이 나올 수 있음)

[핵심 아이디어: 시그모이드 전이 곡선]

각 출력(Blood, Lymph, ECM)을 시그모이드 곡선으로 모델링:

    100% ─────────────────────────╭─────────────
                                 ╱
                                ╱
                               ╱   ← 시그모이드 곡선
                              ╱
    0% ─────────────────────╯─────────────────────
        0h                 36h                72h
                          (전이점)

수식: y(t) = 초기값 + (최종값 - 초기값) × σ(rate × (t - center))

여기서 σ는 시그모이드 함수: σ(x) = 1 / (1 + e^(-x))

[네트워크 역할]
신경망은 4개의 곡선 파라미터를 예측:
- 초기값 (init): t=0에서의 값
- 최종값 (final): t=72h에서의 값
- 전이 속도 (rate): 변화가 얼마나 급격한지
- 전이 중심 (center): 변화가 일어나는 시점

================================================================================
6. 학습 과정 상세
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6.1 보간 모델 (CaseInterpolator) - 학습 불필요
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보간 모델은 학습이 필요 없습니다!
데이터를 로드하고 저장만 하면 바로 사용 가능.

[생성 과정]
```python
def create_interpolator_from_data():
    # 1. 전처리기 초기화
    preprocessor = TimeSeriesPreprocessor(data_dir)

    # 2. Injection site 데이터 로드 (12개 Case, kdecay=0)
    case_data = preprocessor.load_case_data()

    # 3. sol765 Decay 데이터 로드 (12개 시트, 다양한 kdecay)
    decay_data = preprocessor.load_decay_data()

    # 4. 보간기 생성 및 케이스 추가
    interpolator = CaseInterpolator()

    for case_name, data in case_data.items():
        interpolator.add_case(
            case_name=case_name,
            params_normalized=data['params_normalized'],  # [6] 배열
            time_series=data['time_series']               # DataFrame
        )

    for case_name, data in decay_data.items():
        interpolator.add_case(...)

    return interpolator
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6.2 PINN 모델 학습 과정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[파일: train_smooth.py]

[학습 루프 상세]

┌─────────────────────────────────────────────────────────────────────────────┐
│                           학습 1 에폭 (Epoch)                               │
└─────────────────────────────────────────────────────────────────────────────┘

for epoch in range(1, 500):          # 500번 반복
    for x, y in train_loader:        # 배치 단위로 데이터 로드
        │
        │  x: 입력 [batch_size, 6]
        │     - x[:, 0] = 정규화된 시간 (0~1)
        │     - x[:, 1:] = 정규화된 파라미터 5개
        │
        │  y: 타겟 [batch_size, 3]
        │     - Blood, Lymph, ECM 비율 (0~1)
        │
        ▼
    ┌─────────────────────────────────────┐
    │ Step 1: 순전파 (Forward Pass)        │
    │                                     │
    │ pred = model(x)                     │
    │ → 모델이 Blood/Lymph/ECM 예측       │
    └───────────────┬─────────────────────┘
                    ▼
    ┌─────────────────────────────────────┐
    │ Step 2: 손실 계산                    │
    │                                     │
    │ ① 데이터 손실 (MSE)                  │
    │    data_loss = mean((pred - y)²)    │
    │                                     │
    │ ② 부드러움 손실                      │
    │    - 1차 미분: 급격한 변화 방지       │
    │    - 2차 미분: 곡률 최소화           │
    │                                     │
    │ ③ 단조성 손실                        │
    │    - Blood: 시간 따라 증가해야 함     │
    │    - Lymph: 시간 따라 증가해야 함     │
    │    - ECM: 시간 따라 감소해야 함       │
    │                                     │
    │ 총 손실 = data + 0.5×smooth + 0.3×mono│
    └───────────────┬─────────────────────┘
                    ▼
    ┌─────────────────────────────────────┐
    │ Step 3: 역전파 (Backward Pass)       │
    │                                     │
    │ loss.backward()                     │
    │ → 모든 가중치에 대한 기울기 계산      │
    └───────────────┬─────────────────────┘
                    ▼
    ┌─────────────────────────────────────┐
    │ Step 4: 가중치 업데이트              │
    │                                     │
    │ optimizer.step()                    │
    │ → AdamW 옵티마이저로 가중치 조정      │
    │                                     │
    │ 가중치_new = 가중치_old - lr × 기울기  │
    │ (lr = 학습률, 예: 0.001)             │
    └─────────────────────────────────────┘

[손실 함수 상세]

1. 데이터 손실 (Data Loss)
   - 예측값과 실제값의 차이
   - MSE (Mean Squared Error) 사용

   loss = (1/N) × Σ(pred_i - target_i)²

2. 부드러움 손실 (Smoothness Loss)
   - 시간에 따른 급격한 변화 방지

   diff1 = pred[t+1] - pred[t]      # 1차 미분 (변화량)
   diff2 = diff1[t+1] - diff1[t]    # 2차 미분 (가속도)

   loss = mean(diff1²) + 0.5 × mean(diff2²)

3. 단조성 손실 (Monotonicity Loss)
   - 물리적으로 타당한 방향으로만 변화하도록 강제

   Blood 증가 위반 = relu(-diff_blood)   # 감소하면 페널티
   ECM 감소 위반 = relu(diff_ecm)        # 증가하면 페널티

[학습률 스케줄러]
Cosine Annealing: 학습률을 서서히 감소

    lr
    │ 0.001 ●
    │        ╲
    │         ╲
    │          ╲
    │           ●──────●
    │                  0.000001
    └───────────────────────────── epoch
      0                         500

================================================================================
7. 예측 과정 상세
================================================================================

[웹 앱에서의 예측 흐름]

사용자가 파라미터 입력
        │
        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: 파라미터 정규화                                        │
│                                                               │
│ 사용자 입력: Lp_ve = 8e-12, K = 1e-15, kdecay = 1.7e-6, ...  │
│                                                               │
│ 정규화 결과: [0, 0, 0, 0, 0, 0]  ← 모두 중간값이므로 0        │
└───────────────────┬───────────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: 보간기로 예측                                          │
│                                                               │
│ predict_with_interpolator(interpolator, params_normalized)    │
│                                                               │
│ 내부 동작:                                                    │
│   1. 시간 배열 생성: [0, 0.72, 1.44, ..., 72] (100개 포인트)   │
│   2. 각 시간 t에 대해:                                        │
│      a. 가장 가까운 3개 케이스 찾기                           │
│      b. 역거리 가중치 계산                                    │
│      c. 가중 평균으로 Blood/Lymph/ECM/Decay 계산              │
└───────────────────┬───────────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: 결과 DataFrame 생성                                    │
│                                                               │
│ time_hour | Blood | Lymph | ECM   | Decay                     │
│ ───────────────────────────────────────────                   │
│ 0.00      | 0.5   | 1.2   | 98.3  | 0.0                       │
│ 0.72      | 1.1   | 2.5   | 96.4  | 0.0                       │
│ ...       | ...   | ...   | ...   | ...                       │
│ 72.00     | 18.4  | 47.9  | 33.7  | 0.0                       │
└───────────────────┬───────────────────────────────────────────┘
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: 시각화                                                 │
│                                                               │
│ - 시계열 라인 차트 (Plotly)                                   │
│ - 72시간 최종 비율 박스                                       │
│ - AUC 파이 차트                                               │
└───────────────────────────────────────────────────────────────┘

================================================================================
8. 웹 애플리케이션 구조
================================================================================

[파일: app.py]

[Streamlit 앱 구조]

┌─────────────────────────────────────────────────────────────────────────────┐
│                              main()                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐                                                        │
│  │  세션 상태 초기화 │ ← init_session_state()                                │
│  └────────┬────────┘                                                        │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │   모델 로드      │ ← load_interpolator(), load_pretrained_model()        │
│  └────────┬────────┘                                                        │
│           ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐            │
│  │                    사이드바 메뉴                              │            │
│  │  ┌───────────────────────────────────────────────────┐      │            │
│  │  │ 📈 시간별 농도 변화  →  page_time_series()         │      │            │
│  │  │ 🎯 파라미터 입력    →  page_parameter_input()      │      │            │
│  │  │ ℹ️ 도움말          →  page_help()                  │      │            │
│  │  └───────────────────────────────────────────────────┘      │            │
│  └─────────────────────────────────────────────────────────────┘            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

[주요 페이지 설명]

1. page_time_series() - 시간별 농도 변화
   ┌─────────────────────────────────────────────────────────────┐
   │ 좌측 컬럼                    │ 우측 컬럼                      │
   │ ─────────────────────────── │ ─────────────────────────────  │
   │ • 케이스 선택 드롭다운       │ • 라인 차트 (Blood/Lymph/...)  │
   │ • 케이스 파라미터 표시       │ • 데이터 테이블                │
   │ • 데이터 소스 선택          │ • 72시간 최종 분포 박스         │
   │   (원본/PINN/둘 다)         │ • AUC 파이 차트                │
   └─────────────────────────────────────────────────────────────┘

2. page_parameter_input() - 파라미터 직접 입력
   ┌─────────────────────────────────────────────────────────────┐
   │ 좌측 컬럼                    │ 우측 컬럼                      │
   │ ─────────────────────────── │ ─────────────────────────────  │
   │ • Lp_ve 입력                │ • 예측 결과 (72시간)           │
   │ • K 입력                    │   Blood / Lymph / ECM / Decay  │
   │ • P_oncotic 입력            │ • 시계열 그래프                │
   │ • sigma_ve 입력             │ • AUC 파이 차트                │
   │ • D_gel 입력                │                               │
   │ • kdecay 입력               │                               │
   └─────────────────────────────────────────────────────────────┘

[캐싱 메커니즘]

Streamlit의 캐싱 데코레이터 사용:

@st.cache_data          # 데이터 캐싱 (직렬화 가능한 객체)
def load_case_time_series():
    ...

@st.cache_resource      # 리소스 캐싱 (모델, 연결 등)
def load_interpolator():
    ...

장점:
- 페이지 새로고침 시 데이터 재로드 방지
- 빠른 응답 시간

================================================================================
9. 핵심 알고리즘 설명
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9.1 AUC (Area Under Curve) 계산
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[정의]
곡선 아래의 면적을 계산하여 총 노출량을 추정

[사다리꼴 적분법]

    Blood %
    │
 50 │          ●──●──●
    │       ●         ●
 30 │    ●               ●
    │ ●                     ●
 10 │●                         ●
    │
    └──────────────────────────────── 시간
      0   12   24   36   48   60  72h

각 구간을 사다리꼴로 근사:

    면적 = (1/2) × (h₁ + h₂) × Δt

총 AUC = Σ (각 사다리꼴 면적)

[코드]
```python
def calculate_auc(df):
    time = df['time_hour'].values
    auc_blood = np.trapz(df['Blood'].values, time)
    auc_lymph = np.trapz(df['Lymph'].values, time)
    auc_ecm = np.trapz(df['ECM'].values, time)
    auc_decay = np.trapz(df['Decay'].values, time)
    return {'Blood': auc_blood, 'Lymph': auc_lymph,
            'ECM': auc_ecm, 'Decay': auc_decay}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9.2 Cubic Spline 보간
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[목적]
이산적인 시간 데이터를 부드러운 연속 함수로 변환

[원리]
각 구간을 3차 다항식으로 연결하되,
연결점에서 값, 1차 미분, 2차 미분이 연속되도록 함

    ●                              ●
      ╲                          ╱
        ╲    ●──────────●     ╱
          ╲               ╱
            ●           ●

[scipy 사용]
```python
from scipy.interpolate import interp1d

interp_blood = interp1d(
    time_hours,        # x: 알려진 시간 포인트
    blood_values,      # y: 알려진 값
    kind='cubic',      # 3차 스플라인
    fill_value='extrapolate'  # 범위 밖은 외삽
)

# 사용
blood_at_36h = interp_blood(36.0)
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9.3 Softmax 함수
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[목적]
신경망 출력을 확률(비율)로 변환
→ 모든 값이 양수이고 합이 1이 되도록

[수식]
softmax(xᵢ) = exp(xᵢ) / Σⱼ exp(xⱼ)

[예시]
입력: [2.0, 1.0, 0.5]

exp(2.0) = 7.39
exp(1.0) = 2.72
exp(0.5) = 1.65
합계 = 11.76

출력:
- Blood: 7.39 / 11.76 = 0.628 (62.8%)
- Lymph: 2.72 / 11.76 = 0.231 (23.1%)
- ECM: 1.65 / 11.76 = 0.140 (14.0%)

합계 = 100% ✓

================================================================================
10. 용어 사전
================================================================================

[딥러닝 용어]

• 에폭 (Epoch)
  전체 학습 데이터를 한 번 모두 학습하는 단위

• 배치 (Batch)
  한 번에 학습하는 데이터 샘플의 수

• 손실 함수 (Loss Function)
  예측값과 실제값의 차이를 측정하는 함수

• 옵티마이저 (Optimizer)
  손실을 최소화하기 위해 가중치를 업데이트하는 알고리즘
  예: Adam, SGD, AdamW

• 학습률 (Learning Rate)
  가중치 업데이트의 크기를 조절하는 하이퍼파라미터

• 순전파 (Forward Pass)
  입력에서 출력까지 계산하는 과정

• 역전파 (Backward Pass)
  출력에서 입력 방향으로 기울기를 계산하는 과정

• 과적합 (Overfitting)
  학습 데이터에는 잘 맞지만 새로운 데이터에는 잘 맞지 않는 상태

• 정규화 (Normalization)
  데이터를 특정 범위로 스케일링하는 과정

[물리/생물학 용어]

• 림프칩 (Lymph Chip)
  인체의 림프계를 모사한 미세유체 디바이스

• 투과도 (Permeability)
  물질이 막을 통과하는 정도

• 삼투압 (Oncotic Pressure)
  단백질에 의해 발생하는 삼투압

• ECM (Extracellular Matrix)
  세포 외 기질, 세포 사이의 공간

• Decay
  약물 분해, 시간에 따른 약물 소실

[프로젝트 특화 용어]

• 보간기 (Interpolator)
  알려진 데이터 사이의 값을 추정하는 도구

• 정규화된 파라미터
  실제 물리값을 -1 ~ +1 범위로 변환한 값

• IDW (Inverse Distance Weighting)
  거리의 역수를 가중치로 사용하는 보간 방법

================================================================================
                              문서 끝
================================================================================
